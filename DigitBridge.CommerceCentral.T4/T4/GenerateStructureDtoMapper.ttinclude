<#
#>    

//-------------------------------------------------------------------------
// This document is generated by T4
// It will only generate once, if you want re-generate it, you need delete this file first.
// <copyright company="DigitBridge">
//     Copyright (c) DigitBridge Inc.  All rights reserved.
// </copyright>
//-------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using DigitBridge.Base.Utility;
using DigitBridge.CommerceCentral.YoPoco;

namespace <#= NamespaceStructure #>
{
    /// <summary>
    /// Represents a <#= StructureDtoName #>MapperDefault Class.
    /// NOTE: This class is generated from a T4 template Once - you you wanr re-generate it, you need delete cs file and generate again
    /// </summary>
    public class <#= StructureClass.ClassName #>DtoMapperDefault : IDtoMapper<<#= StructureClass.ClassName #>, <#= StructureDtoName #>> 
    {
        #region read from dto to data

        public virtual <#= StructureClass.ClassName #> ReadDto(<#= StructureClass.ClassName #> data, <#= StructureDtoName #> dto)
        {
            if (dto is null)
                return data;
            if (data is null)
            {
                data = new <#= StructureClass.ClassName #>();
                data.New();
            }

<# // call all children read method
            indent = 3;
            foreach(var item in StructureClass.StructureTables)
            { 
                var child = item.Value;
                if (child == null) continue;
                if (child.Table.IsChildrenOfChildren) continue;
                WriteLine($"{new String('\t',indent)}if (dto.{child.Table.Name} != null)");
                WriteLine($"{new String('\t',indent)}{{");
                WriteLine($"{new String('\t',indent+1)}if (data.{child.Table.Name} is null)");
                if (child.OneToOne)
                {
                    WriteLine($"{new String('\t',indent+2)}data.{child.Table.Name} = data.New{child.Table.Name}();");
                    WriteLine($"{new String('\t',indent+1)}Read{child.Table.Name}(data.{child.Table.Name}, dto.{child.Table.Name});");
                }
                else
                {
                    WriteLine($"{new String('\t',indent+2)}data.{child.Table.Name} = new List<{child.Table.Name}>();");
                    WriteLine($"{new String('\t',indent+1)}var deleted = Read{child.Table.Name}(data.{child.Table.Name}, dto.{child.Table.Name});");
                    WriteLine($"{new String('\t',indent+1)}data.SetInvoiceItemsDeleted(deleted);");
                }
                WriteLine($"{new String('\t',indent)}}}");
            }
#>

            data.CheckIntegrity();
            return data;
        }

<# // generate all children read method
    indent = 2;
    foreach(var item in StructureClass.StructureTables)
    { 
        var child = item.Value;
        if (child == null) continue;
        if (child.Table.IsChildrenOfChildren) continue;
#>
<#@ include file="ReadDtoObjectChildren.ttinclude" #>
<#  // generate list children read method
        if (!child.OneToOne)
        {
#>
<#@ include file="ReadDtoListChildren.ttinclude" #>
<#      } #>
<#@ include file="ReadDtoGrandChildrenMethod.ttinclude" #>
<# } #>

        #endregion read from dto to data

        #region write to dto from data

        public virtual <#= StructureDtoName #> WriteDto(<#= StructureClass.ClassName #> data, <#= StructureDtoName #> dto)
        {
            if (data is null)
                return null;
            if (dto is null)
                dto = new <#= StructureDtoName #>();

            data.CheckIntegrity();

<# // call all children write method
            indent = 3;
            foreach(var item in StructureClass.StructureTables)
            { 
                var child = item.Value;
                if (child == null) continue;
                if (child.Table.IsChildrenOfChildren) continue;
                WriteLine($"{new String('\t',indent)}if (data.{child.Table.Name} != null)");
                WriteLine($"{new String('\t',indent)}{{");
                if (child.OneToOne)
                {
                    WriteLine($"{new String('\t',indent+1)}dto.{child.Table.Name} = new {child.Table.DtoName}();");
                }
                else
                {
                    WriteLine($"{new String('\t',indent+1)}dto.{child.Table.Name} = new List<{child.Table.DtoName}>();");
                }
                WriteLine($"{new String('\t',indent+1)}Write{child.Table.Name}(data.{child.Table.Name}, dto.{child.Table.Name});");
                WriteLine($"{new String('\t',indent)}}}");
            }
#>
            return dto;
        }

<# // generate all children write method
    indent = 2;
    foreach(var item in StructureClass.StructureTables)
    { 
        var child = item.Value;
        if (child == null) continue;
        if (child.Table.IsChildrenOfChildren) continue;
#>
<#@ include file="WriteDtoObjectChildren.ttinclude" #>
<# // generate write list for one to many children tables
        if (!child.OneToOne)
        {
#>
<#@ include file="WriteDtoListChildren.ttinclude" #>
<#      } #>

<#@ include file="WriteDtoGrandChildrenMethod.ttinclude" #>
<# } #>

        #endregion write to dto from data

    }
}


